# where Ozone values are above 31 and Temp values are above 90.
# What is the mean of Solar.R in this subset?
hw1_data <- read.csv("~/Downloads/hw1_data.csv")
getwd()
data<-hw1_data
dim(data)  #dimensions of input data
good <- complete.cases(data) #logical vector to weed out NAs
complete.data<-data[good,][,]  #complete data only
names(complete.data) #check names in data frame
ozone.above31.data <- subset(complete.data, Ozone > 31) #subset of data
temp.above90.data <- subset(ozone.above31.data, Temp > 90)  #subset of data
o31andt90.data <- subset(complete.data, Ozone > 31 & Temp > 90) #test both conditions at once
xdata <- data.matrix(o31andt90.data)  # convert to matrix?  need to do this to find mean?
solar<-xdata[,"Solar.R"]
mean(solar)
# Question 19:  Mean Temp when Month = 6
y.df <- subset(data, Month == 6)  #use all the data not the cleaned set
y <- data.matrix(y.df) #convert to matrix
temp <-y[,"Temp"]
mean(temp)
# Question 20: What was the maximum ozone value in the month of May (i.e. Month = 5)?
z.df <- subset(complete.data, Month ==5) #must used "cleaned" data otherwise max() returns NA
z <- data.matrix(z.df) #convert to matrix
ozone <-z[,"Ozone"]
max(ozone)
# R Programming - April 2014
# Week 1 Quiz
# Question 18:  Extract the subset of rows of the data frame
# where Ozone values are above 31 and Temp values are above 90.
# What is the mean of Solar.R in this subset?
hw1_data <- read.csv("~/Downloads/hw1_data.csv")
getwd()
data<-hw1_data
dim(data)  #dimensions of input data
good <- complete.cases(data) #logical vector to weed out NAs
complete.data<-data[good,][,]  #complete data only
names(complete.data) #check names in data frame
ozone.above31.data <- subset(complete.data, Ozone > 31) #subset of data
temp.above90.data <- subset(ozone.above31.data, Temp > 90)  #subset of data
o31andt90.data <- subset(complete.data, Ozone > 31 & Temp > 90) #test both conditions at once
xdata <- data.matrix(o31andt90.data)  # convert to matrix?  need to do this to find mean?
solar<- xdata[,"Solar.R"]
mean(solar)
# Question 19:  Mean Temp when Month = 6
y.df <- subset(data, Month == 6)  #use all the data not the cleaned set
y <- data.matrix(y.df) #convert to matrix
temp <- y[,"Temp"]
mean(temp)
# Question 20: What was the maximum ozone value in the month of May (i.e. Month = 5)?
z.df <- subset(complete.data, Month ==5) #must used "cleaned" data otherwise max() returns NA
z <- data.matrix(z.df) #convert to matrix
ozone <- z[,"Ozone"]
max(ozone)
t.df <- subset(data, Month == 6)
t1 <- t.df[,"Temp"]
mean(t1)
mean(t.df)
mean(t.df[,"Temp"])
mean(subset(data, Month == 6))
mean(subset(data, Month == 6)[,"Temp"])
mean(subset(data, Ozone > 31 & Temp > 90)[,"Solar.R"])
max(subset(data, Month == 5)[,"Ozone"])
max(subset(complete.data, Month == 5)[,"Ozone"])
# R Programming - April 2014
# Week 1 Quiz
# Question 18:  Extract the subset of rows of the data frame
# where Ozone values are above 31 and Temp values are above 90.
# What is the mean of Solar.R in this subset?
hw1_data <- read.csv("~/Downloads/hw1_data.csv")
getwd()
data<-hw1_data
dim(data)  #dimensions of input data
good <- complete.cases(data) #logical vector to weed out NAs
complete.data<-data[good,][,]  #complete data only
names(complete.data) #check names in data frame
ozone.above31.data <- subset(complete.data, Ozone > 31) #subset of data
temp.above90.data <- subset(ozone.above31.data, Temp > 90)  #subset of data
o31andt90.data <- subset(complete.data, Ozone > 31 & Temp > 90) #test both conditions at once
xdata <- data.matrix(o31andt90.data)  # convert to matrix?  need to do this to find mean?
solar<- xdata[,"Solar.R"]
mean(solar)
# Question 19:  Mean Temp when Month = 6
y.df <- subset(data, Month == 6)  #use all the data not the cleaned set
y <- data.matrix(y.df) #convert to matrix
temp <- y[,"Temp"]
mean(temp)
# Question 20: What was the maximum ozone value in the month of May (i.e. Month = 5)?
z.df <- subset(complete.data, Month ==5) #must used "cleaned" data otherwise max() returns NA
z <- data.matrix(z.df) #convert to matrix
ozone <- z[,"Ozone"]
max(ozone)
# Compressed code for Questions 18-20
mean(subset(data, Month == 6)[,"Temp"])
mean(subset(data, Ozone > 31 & Temp > 90)[,"Solar.R"])
max(subset(complete.data, Month == 5)[,"Ozone"])  # need NA removed dataset for max()
# R Programming - April 2014
# Week 1 Quiz
# Question 18:  Extract the subset of rows of the data frame
# where Ozone values are above 31 and Temp values are above 90.
# What is the mean of Solar.R in this subset?
hw1_data <- read.csv("~/Downloads/hw1_data.csv")
getwd()
data<-hw1_data
dim(data)  #dimensions of input data
good <- complete.cases(data) #logical vector to weed out NAs
complete.data<-data[good,][,]  #complete data only
names(complete.data) #check names in data frame
ozone.above31.data <- subset(complete.data, Ozone > 31) #subset of data
temp.above90.data <- subset(ozone.above31.data, Temp > 90)  #subset of data
o31andt90.data <- subset(complete.data, Ozone > 31 & Temp > 90) #test both conditions at once
xdata <- data.matrix(o31andt90.data)  # convert to matrix?  need to do this to find mean?
solar<- xdata[,"Solar.R"]
mean(solar)
# Question 19:  Mean Temp when Month = 6
y.df <- subset(data, Month == 6)  #use all the data not the cleaned set
y <- data.matrix(y.df) #convert to matrix
temp <- y[,"Temp"]
mean(temp)
# Question 20: What was the maximum ozone value in the month of May (i.e. Month = 5)?
z.df <- subset(complete.data, Month ==5) #must used "cleaned" data otherwise max() returns NA
z <- data.matrix(z.df) #convert to matrix
ozone <- z[,"Ozone"]
max(ozone)
# Compressed code for Questions 18-20
# (matches previous results)
mean(subset(data, Month == 6)[,"Temp"])
mean(subset(data, Ozone > 31 & Temp > 90)[,"Solar.R"])
max(subset(complete.data, Month == 5)[,"Ozone"])  # need NA removed dataset for max()
install.packages("swirl")  # Installs swirl
library(swirl)  # Loads swirl
swirl()  # Runs swirl
install.packages("swirl")  # Installs swirl
library(swirl)  # Loads swirl
swirl()  # Runs swirl
#inverse
setwd("~/ProgrammingAssignment2")
## Put comments here that give an overall description of what your
## functions do
## Function to create an object for
## caching a matrix and its inverse
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
inverse <<- NULL
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# Function to calculate the inverse of the object.
# checks to see if the inverse has already been calculated.
# if not, it calculates the inverse and stores it in the object
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse)) {                   # if not empty, return cached inverse
message("getting cached inverse matrix")
return(inverse)
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
#inverse
}
# use functions to generate inverse matrix
size <- 10                                      # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1$set(mydata)                                  # place data into structure
M1$getInverse()                                 # get inverse (empty at this point)
cacheSolve(M1)                                  # calculate the inverse
cacheSolve(M1)                                  # caculate the inverse again (retrieved cached value)
cacheSolve(M1)                                  # caculate the inverse again (retrieved cached value)
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
inverse <<- NULL
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# Function to calculate the inverse of the object.
# checks to see if the inverse has already been calculated.
# if not, it calculates the inverse and stores it in the object
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {                   # if not empty, return cached inverse
message("getting cached inverse matrix")
return(inverse)
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
#inverse
}
# use functions to generate inverse matrix
size <- 1000                                      # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1$set(mydata)                                  # place data into structure
M1$getInverse()                                 # get inverse (empty at this point)
cacheSolve(M1)                                  # calculate the inverse
cacheSolve(M1)                                  # caculate the inverse again (retrieved cached value)
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
inverse <<- NULL
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# Function to calculate the inverse of the object.
# checks to see if the inverse has already been calculated.
# if not, it calculates the inverse and stores it in the object
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {                   # if not empty, return cached inverse
message("getting cached inverse matrix")
#return(inverse)
return
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
#inverse
}
# use functions to generate inverse matrix
size <- 1000                                      # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1$set(mydata)                                  # place data into structure
M1$getInverse()
cacheSolve(M1)                                  # calculate the inverse
cacheSolve(M1)                                  # caculate the inverse again (retrieved cached value)
M1$getInverse()
dim(cacheSolve(M1))
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
inverse <<- NULL
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# Function to calculate the inverse of the object.
# checks to see if the inverse has already been calculated.
# if not, it calculates the inverse and stores it in the object
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {                   # if not empty, return cached inverse
message("getting cached inverse matrix")
#return(inverse)
return
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
#inverse
}
# use functions to generate inverse matrix
size <- 1000                                      # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1$set(mydata)
M1$getInverse()                                 # get inverse (empty at this point)
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
invCached <<- matrix(data = NA, ...)            # reset cached inverse to "empty"
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# Function to calculate the inverse of the object.
# checks to see if the inverse has already been calculated.
# if not, it calculates the inverse and stores it in the object
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {                   # if not empty, return cached inverse
message("getting cached inverse matrix")
#return(inverse)
return
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
#inverse
}
size <- 1000                                      # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1$set(mydata)                                  # place data into structure
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
invCached <<- matrix(NA, 1, 1, FALSE, NULL)            # reset cached inverse to "empty"
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# Function to calculate the inverse of the object.
# checks to see if the inverse has already been calculated.
# if not, it calculates the inverse and stores it in the object
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {                   # if not empty, return cached inverse
message("getting cached inverse matrix")
#return(inverse)
return
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
#inverse
}
size <- 1000                                      # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1$set(mydata)                                  # place data into structure
M1$getInverse()                                 # get inverse (empty at this point)
imat <- cacheSolve(M1)                                  # calculate the inverse
imat_cached <- cacheSolve(M1)                                  # caculate the inverse again (retrieved cached value)
View(imat)
identical(imat, imat_cached)
size <- 10
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1$set(mydata)                                  # place data into structure
M1$getInverse()                                 # get inverse (empty at this point)
imat <- cacheSolve(M1)                                  # calculate the inverse
imat_cached <- cacheSolve(M1)                                  # caculate the inverse again (retrieved cached value)
imat$getInvers()
M1$getInvers()
View(imat)
test <- mydata * imat
test <- mydata %*% imat
View(test)
View(imat)
i <- solve(mydata)
test <- i %*% mydata
test <- mydata %*% i
View(test)
View(test)
environment(M1)
M1
?return
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
invCached <<- matrix(NA, 1, 1, FALSE, NULL)     # reset cached inverse to "empty"
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# Function to calculate the inverse of the object.
# checks to see if the inverse has already been calculated.
# if not, it calculates the inverse and stores it in the object
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {                   # if not empty, return cached inverse
message("getting cached inverse matrix")
return(invisible(inverse))
#return
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
#inverse
}
size <- 1000                                    # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1
M1$set(mydata)                                  # place data into structure
M1
M1$getInverse()                                 # get inverse (empty at this point)
imat <- cacheSolve(M1)                          # calculate the inverse
imat_cached <- cacheSolve(M1)                   # caculate the inverse again (retrieved cached value)
identical(imat, imat_cached)
test <- mydata * imat                           # verify inverse matrix, test should be identity matrix
identity(x)
identity(imat_cached)
M1
M1()
M1
M1()
environment(M1)
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
invCached <<- matrix(NA, 1, 1, FALSE, NULL)     # reset cached inverse to "empty"
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# Function to calculate the inverse of the object.
# checks to see if the inverse has already been calculated.
# if not, it calculates the inverse and stores it in the object
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {                   # if not empty, return cached inverse
message("getting cached inverse matrix")
return(invisible(inverse))
#return
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
#inverse
}
# use functions to generate inverse matrix
size <- 1000                                    # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1
environment(M1)
createClosure <- function() {
x <-5; # the closures state, will be enclosed in the environment
productFunction <- function() { x + 6 }
return(productFunction)
}
product <- createClosure()
product
product()
environment(product)
ls(environment(product))
get("x",environment(product))
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
invCached <<- matrix(NA, 1, 1, FALSE, NULL)     # reset cached inverse to "empty"
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# Function to calculate the inverse of the object.
# checks to see if the inverse has already been calculated.
# if not, it calculates the inverse and stores it in the object
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {              # if not empty, return cached inverse
message("getting cached
inverse matrix")
return(invisible(inverse))      # invisible suppress print()
#return
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
invisible(inverse)
}
M1 <- makeCacheMatrix()                         # create caching data structure
M1
M1()
environment(M1)
size <- 10                                   # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1
environment(M1)
