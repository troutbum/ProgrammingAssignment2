setwd("~/CourseraHW/Rprogramming/ProgrammingAssignment2")
x <- matrix()
dim(x)
class(x0)
class(x)
foo <- matrix()
dim(foo)
foo
class(foo)
is.na(foo)
foo <- 1
class(foo)
?matrix
makeCacheMatrix <- function(x = matrix()) {
#    inverse <- NULL                                         # set inverse matrix to NULL
inverse <- matrix(data = NA, nrow = 1,                  # set inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
inverse <<- NULL
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse)) {                   # if not empty, return cached inverse
message("getting cached inverse matrix")
return(inverse)
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
inverse
}
size <- 10                             # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                 # create caching data structure
M1$set(mydata)                          # place data into structure
M1
M1$getInverse()                         # get the mean (none at this point)
cacheSolve(M1)                           # calculate the mean
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
inverse <<- NULL
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse)) {                   # if not empty, return cached inverse
message("getting cached inverse matrix")
return(inverse)
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
inverse
}
size <- 10                             # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                 # create caching data structure
M1$set(mydata)                          # place data into structure
M1$getInverse()                         # get the mean (none at this point)
cacheSolve(M1)                                  # calculate the inverse
cacheSolve(M1)                                  # caculate the inverse again (retrieved cached value)
x <- matrix()
dim(x)
?is
?is.empty
dim(x) == 1
dim(x) == 1,1
dim(x) == 1
x
dim(x) == 1 & x
dim(x) == 1 & is.na(x)
(dim(x) == 1) & is.na(x)
?dim
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
inverse <<- NULL
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# Function to calculate the inverse of the object.
# checks to see if the inverse has already been calculated.
# if not, it calculates the inverse and stores it in the object
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse)) {                   # if not empty, return cached inverse
message("getting cached inverse matrix")
return(inverse)
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
inverse
}
size <- 10                                      # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1$set(mydata)                                  # place data into structure
M1$getInverse()                                 # get inverse (empty at this point)
cacheSolve(M1)                                  # calculate the inverse
cacheSolve(M1)                                  # caculate the inverse again (retrieved cached value)
proc.time
proc.time()
cacheSolve(M1)                                  # caculate the inverse again (retrieved cached value)
size <- 100                                     # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M2 <- makeCacheMatrix()                         # create caching data structure
M1$set(mydata)                                  # place data into structure
M1$getInverse()                                 # get inverse (empty at this point
cacheSolve(M1)                                  # calculate the inverse
M2$set(mydata)                                  # place data into structure
cacheSolve(M2)                                  # calculate the inverse
cacheSolve(M2)                                  # calculate the inverse
size <- 1000
mydata <- matrix(rnorm(size*size), size, size)
M3$set(mydata)                                  # place data into structure
M3 <- makeCacheMatrix()                         # create caching data structure
M3$set(mydata)                                  # place data into structure
cacheSolve(M3)                                  # calculate the inverse
cacheSolve(M3)                                  # calculate the inverse
